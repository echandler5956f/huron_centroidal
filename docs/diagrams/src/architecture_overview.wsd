@startuml

class EndEffector {
    frame_id: int
    type: int
}

class Phase {
    contacts: {EndEffector: ConvexPlane}
    knot_points: int
    period: Scalar
}

class ConvexPlane {
    surface_basis = scalar[3][3]
    A: float[][]
    b: float[]
    mu: float
}

class ContactSequence {
    sequence: Phase[]
    in_contact_at_phase(ee: EndEffector, i: int): ConvexPlane
    get_phase_idx_from_knot(k: int): int
    collect_end_effectors(): EndEffector[]
}

class State {
}

class CollocationPoint {
    x: Scalar[]
    dx: Scalar[]
    u: Scalar[]

    knot_phase: *KnotPhase
}

class Trajectory {
    trajectory: State[]
}

class LeggedRobot {
    current_state: CentroidalState<float>
    current_trajectory: Trajectory<CentroidalState, float>
    end_effectors: EndEffector[]
    contact_sequence: ContactSequence
}

class Constraints {
    symbolic_state: *CentroidalState<SX>
    casadi_function: Casadi::Function //IDK
}

class Objective {
    symbolic_state: *CentroidalState<SX>
}

class Interpolate {
    differentiation_matrix: float[][]
    continuity_coefficients: float[]
    quadrature_coefficients: float[]
    tau_root: float[]
    compute_matrices(degree: int, scheme: int): void
}

class KnotPhase {
    centroidal_state_points: CentroidalState<Scalar>[]
    control_input_points: ControlInput<Scalar>[]
}

class NLP {
    robot: LeggedRobot
    constraints: Constraints
    objective: Objective
    symbolic_trajectory: Trajectory<CentroidalSate, SX>
    setup_nlp(): void
    solve_nlp(): Trajectory<CentroidalState, float>
}



@enduml